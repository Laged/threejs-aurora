<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Aurora Borealis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Roboto font with weight 900 (Black) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #00000a;
            color: white;
            overflow: hidden; /* Hide scrollbars */
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10; /* Behind the text */
        }
        canvas {
            display: block;
        }

        /* Styles for centered text */
        #info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center the block */
            z-index: 20; /* In front of the canvas */
            width: 100%; /* Full width */
            font-family: 'Roboto', sans-serif;
            pointer-events: none; /* Allow clicks to pass through text */
        }
        #info h1 {
            font-size: 18vw;
            line-height: 1; /* Make lines stack tightly */
        }

        /* Style for slider handles */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px; /* Center thumb on track */
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-black">

    <!-- Canvas will be rendered here, behind #info -->
    <div id="canvas-container"></div>

    <!-- Centered text -->
    <div id="info">
        <h1 class="font-black text-black text-center tracking-tighter">NANO</h1>
        <h1 class="font-black text-black text-center tracking-tighter">INARI</h1>
    </div>

    <!-- Sliders UI -->
    <div id="sliders-container" class="fixed bottom-0 left-0 w-full bg-black bg-opacity-70 p-4 z-30 text-white">
        <div class="max-w-2xl mx-auto grid grid-cols-2 md:grid-cols-4 gap-4">
            <!-- Slider 1: Wave Amplitude (Default 1.0, Range 0-2) -->
            <div class="flex flex-col">
                <label for="waveAmpSlider" class="text-sm font-medium mb-1">Wave Amp</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="waveAmpSlider" min="0" max="2" value="1" step="0.05" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="waveAmpValue" class="text-sm w-8 text-right">1.0</span>
                </div>
            </div>
            <!-- Slider 2: Fresnel Power (Default 2.0, Range 0-4) -->
            <div class="flex flex-col">
                <label for="fresnelPowerSlider" class="text-sm font-medium mb-1">Fresnel Power</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="fresnelPowerSlider" min="0" max="4" value="2" step="0.1" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="fresnelPowerValue" class="text-sm w-8 text-right">2.0</span>
                </div>
            </div>
            <!-- Slider 3: Speed (Default 0.5, Range 0-1) -->
            <div class="flex flex-col">
                <label for="speedSlider" class="text-sm font-medium mb-1">Speed</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="speedSlider" min="0" max="1" value="0.5" step="0.02" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="speedValue" class="text-sm w-8 text-right">0.5</span>
                </div>
            </div>
            <!-- Slider 4: Ray Sharpness (Default 2.0, Range 0-4) -->
            <div class="flex flex-col">
                <label for="raySharpnessSlider" class="text-sm font-medium mb-1">Ray Sharpness</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="raySharpnessSlider" min="0" max="4" value="2" step="0.1" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="raySharpnessValue" class="text-sm w-8 text-right">2.0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Import three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG OBJECT ---
        const CONFIG = {
            // Camera
            cameraPos: new THREE.Vector3(0, 5, 20),
            cameraLookAt: new THREE.Vector3(0, 40, 0),
            cameraPan: true,
            cameraPanSpeed: 0.05,
            cameraPanAmount: 5,

            // Scene
            starCount: 5000,

            // Aurora
            planeSize: {
                width: 100,
                height: 60,
                widthSegs: 100,
                heightSegs: 60
            },
            auroraBaseY: 40,

            // Global multiplier controls
            globalControls: {
                waveAmp: 1.0,
                fresnelPower: 2.0,
                speed: 0.5,
                raySharpness: 2.0
            },

            // Layer definitions
            layers: [
                {
                    z: -5,
                    noiseScale: 0.8,
                    speed: 0.3,
                    color1: new THREE.Color("#00ff88"),
                    color2: new THREE.Color("#80ffcc"),
                    colorTop: new THREE.Color("#ff00ff"),
                    waveFreq: new THREE.Vector2(0.2, 0.1),
                    waveAmp: 15.0,
                    rayFreq: new THREE.Vector2(8.0, 20.0),
                    fresnelPower: 3.0,
                    raySharpness: 2.0
                },
                {
                    z: 0,
                    noiseScale: 1.0,
                    speed: 0.2,
                    color1: new THREE.Color("#00ff44"),
                    color2: new THREE.Color("#66ffaa"),
                    colorTop: new THREE.Color("#ff33aa"),
                    waveFreq: new THREE.Vector2(0.15, 0.15),
                    waveAmp: 20.0,
                    rayFreq: new THREE.Vector2(6.0, 22.0),
                    fresnelPower: 3.5,
                    raySharpness: 2.5
                },
                {
                    z: 5,
                    noiseScale: 1.2,
                    speed: 0.4,
                    color1: new THREE.Color("#33ff66"),
                    color2: new THREE.Color("#aaffcc"),
                    colorTop: new THREE.Color("#ff0066"),
                    waveFreq: new THREE.Vector2(0.25, 0.2),
                    waveAmp: 12.0,
                    rayFreq: new THREE.Vector2(10.0, 18.0),
                    fresnelPower: 2.5,
                    raySharpness: 3.0
                }
            ]
        };
        // --- END CONFIG ---


        let scene, camera, renderer, clock;
        const auroraMaterials = [];

        // --- GLSL SHADER CODE ---
        const glsl_noise = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            // 3-octave Fractal Brownian Motion
            float fbm3(vec3 p) {
                float v = 0.0;
                float a = 0.5;
                v += a * snoise(p);
                p *= 2.0; a *= 0.5;
                v += a * snoise(p);
                p *= 2.0; a *= 0.5;
                v += a * snoise(p);
                return v;
            }
        `;

        // vertexShader to calculate normals
        const vertexShader = `
            uniform float uTime;
            uniform float uSpeed;
            uniform float uNoiseScale;
            uniform vec2 uWaveFreq;
            uniform float uWaveAmp;

            varying vec2 vUv;
            varying float vNoise;
            varying vec3 vWorldPosition;
            varying vec3 vViewDirection;
            varying vec3 vNormal; // Pass normal to fragment

            ${glsl_noise}

            void main() {
                vUv = uv;
                vec3 pos = position;

                // --- 1. Calculate noise for displacement ---
                vec3 noiseP = vec3(
                    pos.x * uNoiseScale * uWaveFreq.x + uTime * uSpeed * 0.2,
                    pos.y * uNoiseScale * uWaveFreq.y,
                    uTime * uSpeed * 0.1
                );
                float waveNoise = snoise(noiseP);

                // --- 2. Calculate noise for normals (by sampling neighbors) ---
                float noiseX = snoise(vec3(
                    (pos.x + 0.01) * uNoiseScale * uWaveFreq.x + uTime * uSpeed * 0.2,
                    pos.y * uNoiseScale * uWaveFreq.y,
                    uTime * uSpeed * 0.1
                ));
                float noiseY = snoise(vec3(
                    pos.x * uNoiseScale * uWaveFreq.x + uTime * uSpeed * 0.2,
                    (pos.y + 0.01) * uNoiseScale * uWaveFreq.y,
                    uTime * uSpeed * 0.1
                ));

                // --- 3. Create displaced positions ---
                vec3 p0 = vec3(pos.x, pos.y, pos.z + waveNoise * uWaveAmp);
                vec3 pX = vec3(pos.x + 0.01, pos.y, pos.z + noiseX * uWaveAmp);
                vec3 pY = vec3(pos.x, pos.y + 0.01, pos.z + noiseY * uWaveAmp);

                // --- 4. Calculate normal from displaced points ---
                vec3 tangent = normalize(pX - p0);
                vec3 bitangent = normalize(pY - p0);
                vNormal = normalize(cross(tangent, bitangent)); // Pass to fragment

                // --- 5. Final vertex position ---
                pos.z += waveNoise * uWaveAmp;

                vNoise = waveNoise;
                vec4 modelViewPosition = modelViewMatrix * vec4(pos, 1.0);
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                vViewDirection = normalize(cameraPosition - worldPosition.xyz);
                gl_Position = projectionMatrix * modelViewPosition;
            }
        `;

        // REVERTED fragmentShader logic
        const fragmentShader = `
            uniform float uTime;
            uniform float uSpeed;
            uniform float uNoiseScale;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColorTop;
            uniform vec2 uRayFreq;
            uniform float uFresnelPower;
            uniform float uRaySharpness;
            // REMOVED: uniform sampler2D uFalloffTexture;

            varying vec2 vUv;
            varying float vNoise;
            varying vec3 vWorldPosition;
            varying vec3 vViewDirection;
            varying vec3 vNormal;

            ${glsl_noise}

            // Slow noise mask for varying streak length
            float getStreakMask(vec2 uv, float time, float noiseScale) {
                float maskNoise = snoise(vec3(
                    uv.x * noiseScale * 0.5,
                    uv.y * noiseScale * 1.0,
                    time * uSpeed * 0.05
                ));
                return smoothstep(0.1, 0.4, maskNoise);
            }

            // fbm3 for rays
            float getRayPattern(vec2 uv, float time, float noiseScale, float sharpness) {
                float rays = fbm3(vec3(
                    uv.x * noiseScale * uRayFreq.x + time * uSpeed * 0.5,
                    uv.y * noiseScale * uRayFreq.y,
                    time * uSpeed * 0.1
                ));

                float streakMask = getStreakMask(uv, time, noiseScale);
                rays *= streakMask;

                rays = pow(abs(rays), sharpness);
                return rays;
            }

            // Vertical fade
            float getVerticalShape(vec2 uv) {
                float shape = smoothstep(0.0, 0.3, uv.y) * (1.0 - smoothstep(0.7, 1.0, uv.y));
                return shape;
            }

            // Horizontal fade
            float getHorizontalShape(vec2 uv) {
                float shape = smoothstep(0.0, 0.2, uv.x) * (1.0 - smoothstep(0.8, 1.0, uv.x));
                return shape;
            }

            // Correct fresnel logic
            float getFresnel(vec3 viewDir, vec3 worldNormal, float power) {
                float dotVN = abs(dot(normalize(viewDir), normalize(worldNormal)));
                float fresnel = pow(1.0 - dotVN, power);
                return clamp(fresnel, 0.0, 1.0);
            }

            void main() {
                float rayPattern = getRayPattern(vUv, uTime, uNoiseScale, uRaySharpness);
                float verticalShape = getVerticalShape(vUv);
                float horizontalShape = getHorizontalShape(vUv);
                float shape = verticalShape * horizontalShape;

                float fresnel = getFresnel(vViewDirection, vNormal, uFresnelPower);

                // --- REVERTED: Back to procedural pow() falloff ---

                // 1. Calculate base intensity components
                float baseIntensity = rayPattern * shape;
                float glowIntensity = fresnel * 0.8 * shape;
                float minGlow = 0.1 * shape;

                // 2. Calculate the intensity for the COLOR (soft fall-off, "long tail")
                float colorIntensity = baseIntensity + glowIntensity + minGlow;
                colorIntensity = pow(colorIntensity, 0.75); // "Long Tail"

                // 3. Calculate the intensity for the ALPHA (sharp fall-off)
                float alphaIntensity = baseIntensity + glowIntensity + minGlow;
                alphaIntensity = pow(alphaIntensity, 1.5); // "Sharp Start"

                // --- Color by Y-Position (Unchanged) ---

                // 1. Mix base green colors
                vec3 color = mix(uColor1, uColor2, colorIntensity);

                // 2. Mix with top color based on height (vUv.y)
                float yMix = smoothstep(0.6, 0.9, vUv.y);
                color = mix(color, uColorTop, yMix);

                // Use the two different intensity curves for color and alpha
                gl_FragColor = vec4(color * colorIntensity, alphaIntensity);
            }
        `;

        function init() {
            // --- Basic Setup ---
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CONFIG.cameraPos);
            camera.lookAt(CONFIG.cameraLookAt);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // --- Create Stars ---
            createStars();

            // --- Create Auroras ---
            for (const layer of CONFIG.layers) {
                // REVERTED: Removed falloffTexture argument
                createAuroraLayer(
                    layer.z,
                    layer.noiseScale,
                    layer.speed,
                    layer.color1,
                    layer.color2,
                    layer.colorTop,
                    layer.waveFreq,
                    layer.waveAmp,
                    layer.rayFreq,
                    layer.fresnelPower,
                    layer.raySharpness
                );
            }

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            setupSliderListeners();

            // --- Start Animation Loop ---
            animate();
        }

        // REVERTED: Function signature updated
        function createAuroraLayer(zPos, noiseScale, speed, color1, color2, colorTop, waveFreq, waveAmp, rayFreq, fresnelPower, raySharpness) {

            const geometry = new THREE.PlaneGeometry(
                CONFIG.planeSize.width,
                CONFIG.planeSize.height,
                CONFIG.planeSize.widthSegs,
                CONFIG.planeSize.heightSegs
            );

            // REVERTED: Removed uFalloffTexture uniform
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uSpeed: { value: speed },
                    uNoiseScale: { value: noiseScale },
                    uColor1: { value: color1 },
                    uColor2: { value: color2 },
                    uColorTop: { value: colorTop },
                    uWaveFreq: { value: waveFreq },
                    uWaveAmp: { value: waveAmp },
                    uRayFreq: { value: rayFreq },
                    uFresnelPower: { value: fresnelPower },
                    uRaySharpness: { value: raySharpness }
                    // REMOVED: uFalloffTexture
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            });

            // Store base values for slider modification
            material.layerConfig = {
                waveAmp: waveAmp,
                fresnelPower: fresnelPower,
                speed: speed,
                raySharpness: raySharpness
            };

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, CONFIG.auroraBaseY, zPos);

            scene.add(mesh);
            auroraMaterials.push(material);
        }

        function createStars() {
            const starCount = CONFIG.starCount;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 1000; // x
                positions[i3 + 1] = (Math.random() - 0.5) * 1000; // y
                positions[i3 + 2] = (Math.random() - 0.5) * 1000; // z
            }

            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // Setup listeners for all 4 sliders
        function setupSliderListeners() {
            const waveAmpSlider = document.getElementById('waveAmpSlider');
            const waveAmpValue = document.getElementById('waveAmpValue');
            const fresnelPowerSlider = document.getElementById('fresnelPowerSlider');
            const fresnelPowerValue = document.getElementById('fresnelPowerValue');
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            const raySharpnessSlider = document.getElementById('raySharpnessSlider');
            const raySharpnessValue = document.getElementById('raySharpnessValue');

            waveAmpSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                CONFIG.globalControls.waveAmp = val;
                waveAmpValue.textContent = val.toFixed(2);
            });

            fresnelPowerSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                CONFIG.globalControls.fresnelPower = val;
                fresnelPowerValue.textContent = val.toFixed(2);
            });

            speedSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                CONFIG.globalControls.speed = val;
                speedValue.textContent = val.toFixed(2);
            });

            raySharpnessSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                CONFIG.globalControls.raySharpness = val;
                raySharpnessValue.textContent = val.toFixed(2);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Get global multipliers from sliders
            const ampMult = CONFIG.globalControls.waveAmp;
            const fresnelMult = CONFIG.globalControls.fresnelPower;
            const speedMult = CONFIG.globalControls.speed;
            const sharpnessMult = CONFIG.globalControls.raySharpness;

            // Update uniforms for each aurora layer
            auroraMaterials.forEach(material => {
                const baseConfig = material.layerConfig;

                material.uniforms.uWaveAmp.value = baseConfig.waveAmp * ampMult;
                material.uniforms.uFresnelPower.value = baseConfig.fresnelPower * fresnelMult;
                material.uniforms.uSpeed.value = baseConfig.speed * speedMult;
                material.uniforms.uRaySharpness.value = baseConfig.raySharpness * sharpnessMult;

                material.uniforms.uTime.value = elapsedTime;
            });

            // Gently pan the camera
            if (CONFIG.cameraPan) {
                const pan = Math.sin(elapsedTime * CONFIG.cameraPanSpeed) * CONFIG.cameraPanAmount;
                camera.position.x = CONFIG.cameraPos.x + pan;
                camera.lookAt(
                    CONFIG.cameraLookAt.x + pan * 0.5,
                    CONFIG.cameraLookAt.y,
                    CONFIG.cameraLookAt.z
                );
            } else {
                camera.lookAt(CONFIG.cameraLookAt);
            }

            renderer.render(scene, camera);
        }

        // --- Start everything ---
        init();

    </script>
</body>
</html>
